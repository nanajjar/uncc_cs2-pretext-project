<section xml:id="ch-substring-replacement">
  <title>3. Advanced String Methods</title>

  <!-- =====================================================
       1. WHY ARE WE HERE? INTRO & MOTIVATION
       ===================================================== -->
  <subsection xml:id="intro-motivation-substring">
    <title>Introduction &amp; Motivation</title>
    <p>Building on our previous lessons, you now understand basic inspection (<c>length()</c>, <c>isEmpty()</c>, <c>charAt()</c>) and comparison (<c>equals()</c>, <c>compareTo()</c>) in Java strings. Imagine you're now writing a text editor or a command-line parser. The user's input might need trimming, slicing, or partial replacement. For instance, you might remove a prefix like <c>"/"</c> from <c>"/logout"</c> to get <c>"logout"</c>, or replace every occurrence of <c>"--"</c> with a single dash.</p>
    <p>In Java, these tasks typically involve methods like <c>substring()</c>, <c>indexOf()</c>, <c>replace()</c>, and more. But how do we systematically ensure that these methods handle edge cases, invalid indices, empty strings, or multi-character patterns? The Design Recipe's <strong>Step 3 (Examples &amp; Tests)</strong> is crucial here. Creating <em>explicit examples</em> before coding is a powerful guardrail: it reveals hidden assumptions, clarifies edge behaviors, and ensures thorough verification.</p>
  </subsection>

  <!-- =====================================================
       2. REVISITING THE DESIGN RECIPE STEPS
       ===================================================== -->
  <subsection xml:id="recap-design-recipe">
    <title>Recap: Where We Are in the Design Recipe</title>
    <p>So far, we've introduced or spotlighted:</p>
    <ul>
      <li><strong>Step 1 (Data Definition):</strong> We represented our custom <c>MyString</c> with a <c>char[] chars</c> and an <c>int usedLength</c>.</li>
      <li><strong>Step 2 (Method Signatures &amp; Purpose):</strong> We crafted clear JavaDoc for <c>equals()</c>, <c>compareTo()</c>, etc., specifying inputs, outputs, and how the methods behave in special cases like <c>null</c>.</li>
    </ul>
    <p>In this chapter, we'll <em>spotlight Step 3</em>—<em>Examples &amp; Tests</em>. While we've been creating tables of test cases throughout, this section will dive deeper into how to build them rigorously, show multiple “solution attempts,” and highlight how we choose final test coverage. Along the way, we'll implement new methods in <c>MyString</c>: <c>substring()</c>, <c>indexOf()</c>, and <c>replace()</c>—all heavily reliant on robust examples.</p>
  </subsection>

  <!-- =====================================================
       3. COMMON PITFALLS WHEN NOT USING STEP 3 PROPERLY
       ===================================================== -->
  <subsection xml:id="common-pitfalls-step3">
    <title>Common Pitfalls When Neglecting Examples &amp; Tests</title>
    <p>Why do we <em>need</em> a formal Step 3? Let's look at what happens if we skip it or rush through:</p>
    <ul>
      <li><em>Hidden edge cases:</em> For <c>substring()</c>, what if the start/end indices are equal? Negative? Larger than <c>length()</c>? Without explicit tests, these details often go unnoticed until runtime errors arise.</li>
      <li><em>Misaligned assumptions:</em> A teammate might assume <c>indexOf("cat")</c> returns <c>-1</c> when <c>"cat"</c> isn't found, while you plan to raise an exception. A written example clarifies these expectations early.</li>
      <li><em>Incomplete coverage:</em> If we test only “normal” cases (e.g., <c>substring(1, 3)</c> in <c>"Hello"</c>), we might overlook empty strings, boundary indices, or one-character slices. Real software usage will exploit all of these conditions.</li>
    </ul>
    <p>Hence, carefully enumerating scenarios in a test table ensures we cover typical usage, edge conditions, and invalid inputs. Next, we'll apply Step 3 to new methods in <c>MyString</c> that mimic Java's <c>substring</c>, <c>indexOf</c>, and <c>replace</c>.</p>
  </subsection>

  <!-- =====================================================
       4. PLANNING NEW METHODS (STEP 0 & STEP 1 QUICK REVIEW)
       ===================================================== -->
  <subsection xml:id="planning-new-methods">
    <title>Planning Our New Methods (Step 0 &amp; Step 1 in Brief)</title>
    <p>Before diving into test tables, let's state what each method <em>is supposed to do</em> (Step 0: Understand &amp; Restate the Problem) and confirm it aligns with our <c>MyString</c> data structure (Step 1: Data Definition). We'll keep these reviews concise, since the spotlight is on Step 3.</p>

    <subsubsection xml:id="substring-purpose">
      <title><c>substring(int start, int end)</c></title>
      <p><term>Goal:</term> Return a new <c>MyString</c> that contains the characters from index <c>start</c> (inclusive) up to <c>end</c> (exclusive). <em>Constraints &amp; questions:</em></p>
      <ul>
        <li>What if <c>start == end</c>? We'd get an empty substring.</li>
        <li>What if <c>start &lt; 0</c> or <c>end &gt; usedLength</c>?</li>
        <li>Will we throw an error or just clamp the indices? (We'll decide in Step 3 examples.)</li>
      </ul>
      <p><term>Data definition check:</term> We can easily create a new <c>MyString</c> from a slice of <c>chars[]</c>. The only difference is we might have fewer characters in the result. That's consistent with our <c>char[] + usedLength</c> representation.</p>
    </subsubsection>

    <subsubsection xml:id="indexof-purpose">
      <title><c>indexOf(String target)</c></title>
      <p><term>Goal:</term> Return the first index at which <c>target</c> appears in <c>this</c> string, or <c>-1</c> if not found. <em>Constraints &amp; questions:</em></p>
      <ul>
        <li>How do we handle an empty <c>target</c>? Java's <c>indexOf("")</c> returns 0. We'll decide if we mimic that or do something else.</li>
        <li>What if <c>target</c> is longer than <c>this</c> string? Typically the result is <c>-1</c> (no match).</li>
        <li>Case sensitivity? We'll assume yes for now, unless our examples say otherwise.</li>
      </ul>
      <p><term>Data definition check:</term> We'll likely do a nested loop: for each position <c>i</c> in <c>chars[]</c>, check if the substring starting at <c>i</c> matches <c>target</c>. If yes, return <c>i</c>.</p>
    </subsubsection>

    <subsubsection xml:id="replace-purpose">
      <title><c>replace(String find, String replacement)</c></title>
      <p><term>Goal:</term> Return a new <c>MyString</c> in which every occurrence of <c>find</c> is replaced with <c>replacement</c>. <em>Constraints &amp; questions:</em></p>
      <ul>
        <li>Overlapping matches: if we're replacing <c>"ana"</c> in <c>"bananas"</c>, do we match just once at index 1 or also at index 3? Java typically replaces non-overlapping from left to right.</li>
        <li>Potential length expansion or contraction: replacing <c>"cat"</c> with <c>"Meow"</c> changes length by +1. Our <c>MyString</c> has a 100-char limit—what if it exceeds 100 after replacements?</li>
      </ul>
      <p><term>Data definition check:</term> We need a systematic approach to build the new result. We might do repeated <c>indexOf</c> calls and copy segments piece by piece. Or we might adopt a simpler approach with constraints. This is the sort of design choice that clarifies in Step 3 and Step 4. But for now, we know it's feasible to create a new <c>MyString</c> with the replaced content as long as we manage the 100-char boundary carefully.</p>
    </subsubsection>
  </subsection>

  <!-- =====================================================
       5. SPOTLIGHT ON STEP 3: BUILDING EXAMPLES & TESTS
       ===================================================== -->
  <subsection xml:id="spotlight-step3">
    <title>Step 3 Spotlight: Building Examples &amp; Tests</title>
    <p>Now comes our main focus: enumerating examples for normal, edge, and error scenarios. Below, you'll see we create a comprehensive table for each new method. Then we'll walk through how to convert these rows into actual test code. We'll present two alternative “solution attempts” to highlight potential mistakes or oversights, and end by choosing the final test approach that best fits our class.</p>

    <!-- ======================================
         SUBSTRING EXAMPLES
         ====================================== -->
    <subsubsection xml:id="substring-examples">
      <title><c>substring(int start, int end)</c> Examples &amp; Tests</title>
      <p>We want to handle normal cases, edge cases, and invalid indices. Let's propose we <em>throw an <c>IndexOutOfBoundsException</c></em> if <c>start</c> or <c>end</c> is out of range, rather than silently clamping. This approach matches Java's real <c>String.substring</c> behavior. Our table might look like this:</p>
      <listing xml:id="substring-test-table">
        <title>Test Cases for <c>substring(start, end)</c></title>
        <program language="text">
| Case                | Input MyString | start | end | Expected Result        | Notes                                             |
|---------------------|---------------|-------|-----|------------------------|---------------------------------------------------|
| Normal slice        | "Hello"       | 1     | 4   | "ell"                 | 'e'=index1, 'l'=2, 'l'=3; excludes 'o'(index4)   |
| Start=End           | "Hello"       | 2     | 2   | "" (empty)            | Substring with no chars                          |
| Full slice          | "Hello"       | 0     | 5   | "Hello"               | Entire string returned                           |
| start&lt;0 (error)     | "Hello"       | -1    | 3   | Exception thrown      | Expect IndexOutOfBoundsException                 |
| end&gt;length (error)  | "Hello"       | 0     | 10  | Exception thrown      | end beyond usedLength                            |
| start&gt;end (error)   | "Hello"       | 4     | 3   | Exception thrown      | start cannot be greater than end                |
| Empty string        | ""           | 0     | 0   | ""                    | Substring from empty is still empty             |
        </program>
      </listing>
      <p>As you can see, we are explicit about how the method should behave in every corner case—an important hallmark of Step 3. Later, in Step 5, we'll confirm that our code either returns the correct slice or throws the specified exception for each row.</p>

    </subsubsection>

    <!-- ======================================
         INDEXOF EXAMPLES
         ====================================== -->
    <subsubsection xml:id="indexof-examples">
      <title><c>indexOf(String target)</c> Examples &amp; Tests</title>
      <p>Our next method locates the first occurrence of <c>target</c>. Let's agree to return <c>-1</c> if not found, which matches Java's convention. For an empty <c>target</c> (<c>""</c>), we'll follow Java's standard of returning <c>0</c> (the match is at the beginning). Here's our test table:</p>
      <listing xml:id="indexof-test-table">
        <title>Test Cases for <c>indexOf(target)</c></title>
        <program language="text">
| Case                             | Input MyString   | target   | Expected Result | Notes                                                                    |
|---------------------------------|------------------|----------|-----------------|--------------------------------------------------------------------------|
| target found in middle          | "banana"         | "ana"    | 1               | "b[ana]na" => first "ana" starts at index 1                             |
| target found at start           | "banana"         | "ban"    | 0               | "ban" matches from index 0                                              |
| target found at end             | "banana"         | "na"     | 4               | "bana[na]" => starts at index 4                                         |
| target not found                | "banana"         | "cat"    | -1              | "cat" doesn't appear                                                    |
| empty target => index=0         | "banana"         | ""       | 0               | Java convention is to treat "" as found at index 0                      |
| longer target => no match       | "cat"            | "cater"  | -1              | can't find "cater" in a shorter string                                  |
| repeated pattern => first match | "aaaa"           | "aa"     | 0               | "aa" first appears at 0, though also at index 1, 2                      |
| empty MyString                  | ""               | "test"   | -1              | cannot find anything in an empty string                                 |
| both empty => 0?                | ""               | ""       | 0               | consistent with the "empty target => 0" rule                            |
| null target => ???              | "banana"         | null     | ???             | We must decide (maybe throw a NullPointerException, or return -1).       |
        </program>
      </listing>
      <p>Notice the final row is tricky. <c>indexOf(null)</c> is undefined in standard Java and throws a <c>NullPointerException</c>. We can mimic that or define our own approach (like returning <c>-1</c>). The key is that <em>we decide and document</em> it. That's exactly the purpose of Step 3: to flush out ambiguous spots <em>before</em> coding.</p>
    </subsubsection>

    <!-- ======================================
         REPLACE EXAMPLES
         ====================================== -->
    <subsubsection xml:id="replace-examples">
      <title><c>replace(String find, String replacement)</c> Examples &amp; Tests</title>
      <p>Finally, let's tackle <c>replace</c>. Here's a bigger, more complex table because the logic can be trickier. We'll assume left-to-right, non-overlapping replacements like Java's <c>String.replace</c> (i.e., once a replacement is done, we skip past it). Let's also decide that if the result would exceed 100 characters, we will <em>truncate</em> it to 100. (An alternative might be to throw an exception or partially skip replacements—this is up to us.)</p>
      <listing xml:id="replace-test-table">
        <title>Test Cases for <c>replace(find, replacement)</c></title>
        <program language="text">
| Case                                 | Input MyString       | find   | replacement | Expected Result         | Notes                                                                   |
|-------------------------------------|----------------------|--------|------------|-------------------------|-------------------------------------------------------------------------|
| Find occurs once                     | "hello world"        | "world"| "Java"     | "hello Java"           | straightforward single replacement                                     |
| Find occurs multiple times          | "banana banana"      | "ana"  | "X"        | "bXna bXna"            | each "ana" replaced with "X", skipping overlaps left-to-right          |
| Find doesn't occur                  | "hello"              | "cat"  | "dog"      | "hello"                | unchanged                                                              |
| Empty find => ???                   | "abc"                | ""     | "?"        | ???                     | does Java treat empty find as always matching? Typically yes, but tricky or we disallow it?                 |
| Replacement longer than find        | "cat"                | "a"    | "longer"   | "clonger t" (??? see note) | length grows from 3 to 8. Must check 100-char limit. Possibly "clonger t" if we accept the growth.       |
| Replacement shorter than find       | "aaaa"               | "aa"   | "*"        | "**"                    | first "aa" -&gt; "*", second "aa" -&gt; "*", total 2 replacements.            |
| Replacement yields &gt;100 chars       | (string near 100 char)| "x"    | "xyz"      | truncated result        | we must confirm the final length is capped at 100, or throw error.      |
| Null find => ???                    | "abc"                | null   | "XYZ"      | ???                     | Decide if that's an error or no-op. (Likely throw NullPointerException) |
| Null replacement => ???             | "abc abc"            | "abc"  | null       | ???                     | Possibly treat as "" or throw an error. Step 3 is clarifying this.      |
        </program>
      </listing>
      <p>A more thorough method like <c>replace</c> can quickly reveal how many edge decisions exist in real software. By enumerating them explicitly, we avoid confusion down the line. You can see how Step 3 helps the entire team align on details like “What happens if the replacement is <c>null</c>?” or “Do we replace an empty string everywhere?” or “Is the entire result truncated at 100 characters?” We'll lock in these rules, specify them in Step 2's method doc, and then ensure our final code passes each scenario above.</p>
    </subsubsection>

  </subsection>

  <!-- =====================================================
       6. HOW DO WE TEST? TWO ALTERNATIVE APPROACHES
       ===================================================== -->
  <subsection xml:id="two-approaches-testing">
    <title>Two Alternative Approaches to Testing</title>
    <p>Now that we have our tables, how do we turn them into real tests? We'll briefly illustrate two “solution attempts” for writing tests and show why we'll prefer one in the final code.</p>

    <subsubsection xml:id="test-attempt1-asserts">
      <title>Attempt #1: Manual <c>assert</c> or Print Checking</title>
      <p>In earlier chapters, we used simple <c>assert</c> statements or <c>System.out.println</c> checks. For example:</p>
      <program language="java">
        <input>
public static void testSubstring() {
    MyString s = new MyString("Hello");
    
    // Normal slice
    MyString result = s.substring(1, 4);
    assert result.equals("ell") : "Expected 'ell'";

    // start=end
    MyString emptyResult = s.substring(2, 2);
    assert emptyResult.equals("") : "Expected ''";
    
    // ...
    System.out.println("testSubstring() passed basic checks");
}
        </input>
      </program>
      <p><term>Pros:</term> Very simple to write and read. <term>Cons:</term> Harder to scale for large test sets; we rely on the <c>assert</c> error messages or manual prints. Also, in many production environments, <c>assert</c> might be disabled by default unless you use <c>-ea</c> on the JVM command line.</p>
    </subsubsection>

    <subsubsection xml:id="test-attempt2-junit">
      <title>Attempt #2: A Simple <c>JUnit</c> or <c>TestNG</c> Class</title>
      <p>Modern Java typically uses frameworks like <c>JUnit</c>, <c>TestNG</c>, or <c>Mockito</c>. Below is a minimal <c>JUnit</c> example showing how we can do the same checks in a formal test class. This yields nicer reporting and integration with IDE test runners or CI pipelines.</p>
      <program language="java">
        <input>
import static org.junit.Assert.*;
import org.junit.Test;

public class MyStringTests {

    @Test
    public void testSubstringNormal() {
        MyString s = new MyString("Hello");
        MyString result = s.substring(1, 4);
        assertTrue("Expected 'ell'", result.equals("ell"));
    }

    @Test
    public void testSubstringEmptySlice() {
        MyString s = new MyString("Hello");
        MyString emptyRes = s.substring(2, 2);
        assertTrue("Expected ''", emptyRes.equals(""));
    }

    // ... etc.
}
        </input>
      </program>
      <p><term>Pros:</term> Industry-standard approach, easy to expand, integrates with build tools (Maven, Gradle). <term>Cons:</term> Slightly more setup overhead for new students, requires library familiarity. But many instructors prefer teaching JUnit early, as it fosters “real” testing habits.</p>
      <p>For the final example in this chapter, we'll use the manual <c>assert</c> style (Attempt #1) inline, because it's self-contained and consistent with prior chapters. However, you're encouraged to replicate these tests in a dedicated JUnit class if you're comfortable with it.</p>
    </subsubsection>
  </subsection>

  <!-- =====================================================
       7. STEP 4: SKELETON FOR OUR NEW METHODS
       ===================================================== -->
  <subsection xml:id="step4-skeleton-new-methods">
    <title>Step 4: Skeleton Out Our New Methods</title>
    <p>Let's outline pseudocode for each new method, referencing the decisions from Step 3. We'll keep it short here, focusing on the major steps. Later, we'll fill in the details (Step 5).</p>
    <program language="java">
      <input>
public class MyString {
    // Existing fields, constructor, etc.

    /**
     * Returns a new MyString from [start, end).
     * Throws IndexOutOfBoundsException if invalid.
     */
    public MyString substring(int start, int end) {
        // 1) Validate 0 &lt;= start &lt;= end &lt;= usedLength
        // 2) Allocate a new MyString with capacity = (end - start)
        // 3) Copy chars from this.chars[start..end-1] into new object
        // 4) Return new object
        return null; // skeleton placeholder
    }

    /**
     * Finds the first index of 'target', or -1 if none.
     * Possibly throws NullPointerException if target is null.
     */
    public int indexOf(String target) {
        // 1) If target == null => throw NullPointerException or decide otherwise
        // 2) If target.length() == 0 => return 0  (Java convention)
        // 3) For i in [0..usedLength-target.length()]
        //    - Check if substring from i matches target
        //    - If yes => return i
        // 4) Return -1 if not found
        return -1; // skeleton placeholder
    }

    /**
     * Returns a new MyString replacing every occurrence of 'find' with 'replacement',
     * left to right, skipping overlaps, truncated to 100 if needed.
     */
    public MyString replace(String find, String replacement) {
        // 1) Decide on null handling for find or replacement
        // 2) If find is empty => define a policy (insert replacement at every index? or error?)
        // 3) Loop through 'this' from left to right:
        //    - If we see 'find', append 'replacement' to a buffer, else copy current char
        //    - Track total length to avoid exceeding 100
        // 4) Build final MyString from the result
        return null; // skeleton placeholder
    }
}
      </input>
    </program>
    <p>These skeletons match perfectly with the test tables from Step 3. For instance, you see explicit checks for invalid bounds in <c>substring</c> and the question about empty <c>find</c> in <c>replace</c>. No guesswork—our test tables already spelled out each scenario we must handle.</p>
  </subsection>

  <!-- =====================================================
       8. STEP 5: IMPLEMENTATION, DRIVEN BY EXAMPLES
       ===================================================== -->
  <subsection xml:id="step5-implementation-spotlight3">
    <title>Step 5: Implementation &amp; Testing (Guided by Step 3 Examples)</title>
    <p>We'll now fill in each method. Notice how the test tables we created in Step 3 serve as a direct checklist for verifying correctness. After each method, we'll show snippet-level tests, referencing the rows from our table. Let's proceed in small increments and re-test frequently, as the Design Recipe recommends.</p>

    <subsubsection xml:id="substring-implementation">
      <title>8.1 <c>substring</c> Implementation &amp; Tests</title>
      <program language="java">
        <input>
/**
 * Returns a new MyString from [start, end).
 * Throws IndexOutOfBoundsException if start or end is invalid.
 */
public MyString substring(int start, int end) {
    // Validate
    if (start &lt; 0 || end &lt; 0 || start &gt; end || end &gt; usedLength) {
        throw new IndexOutOfBoundsException(
            "Invalid substring range: [" + start + ", " + end + ") for length " + usedLength
        );
    }
    // Compute length of new substring
    int subLen = end - start;

    // Build a plain Java String temporarily
    // (Alternatively, we could build MyString directly, but let's do an intermediate step)
    StringBuilder sb = new StringBuilder(subLen);
    for (int i = start; i &lt; end; i++) {
        sb.append(chars[i]);
    }

    // Create a new MyString from that
    return new MyString(sb.toString());
}

// Quick test snippet
public static void main(String[] args) {
    MyString m = new MyString("Hello");

    // Should print "ell"
    MyString sub = m.substring(1, 4);
    System.out.println("Substring(1,4) => " + sub.toString()); // We'll define toString() below

    // Should print "" (empty string)
    MyString subEmpty = m.substring(2, 2);
    System.out.println("Substring(2,2) => " + subEmpty.toString());

    // Should throw IndexOutOfBoundsException
    try {
        m.substring(-1, 3);
    } catch (IndexOutOfBoundsException e) {
        System.out.println("Caught expected exception for [-1,3]");
    }
}
        </input>
      </program>
      <p>Here, each test snippet corresponds to a row in our substring test table. We confirm that normal slices work, an empty slice yields an empty string, and out-of-range inputs raise the proper exception. This direct mapping from table row to test code is the hallmark of a thorough Step 3 practice.</p>
    </subsubsection>

    <subsubsection xml:id="indexof-implementation">
      <title>8.2 <c>indexOf</c> Implementation &amp; Tests</title>
      <program language="java">
        <input>
/**
 * Returns the first index where 'target' occurs, or -1 if none.
 * @throws NullPointerException if target is null (matching standard Java)
 */
public int indexOf(String target) {
    // 1) Null check
    if (target == null) {
        throw new NullPointerException("indexOf received null 'target'");
    }

    // 2) Empty target => 0
    if (target.length() == 0) {
        return 0;
    }

    // 3) Search
    for (int start = 0; start &lt;= usedLength - target.length(); start++) {
        // Check if substring from [start .. start+target.length()) matches
        int i = 0;
        while (i &lt; target.length() &amp;&amp; chars[start + i] == target.charAt(i)) {
            i++;
        }
        if (i == target.length()) {
            // Found complete match
            return start;
        }
    }

    return -1;
}

// Quick test snippet in main:
public static void main(String[] args) {
    // ...
    MyString m2 = new MyString("banana");
    System.out.println("m2.indexOf(\"ana\") => " + m2.indexOf("ana")); // Expect 1
    System.out.println("m2.indexOf(\"ban\") => " + m2.indexOf("ban")); // Expect 0
    System.out.println("m2.indexOf(\"cat\") => " + m2.indexOf("cat")); // Expect -1
    System.out.println("m2.indexOf(\"\") => " + m2.indexOf(""));       // Expect 0

    try {
        m2.indexOf(null); // Should throw exception
    } catch (NullPointerException e) {
        System.out.println("Caught expected NullPointerException for indexOf(null)");
    }
}
        </input>
      </program>
      <p>Each test line directly corresponds to a row in the <c>indexOf</c> table. We confirmed multiple occurrences (<c>"banana"</c>), an unfound substring, an empty <c>target</c>, and the <c>null</c> scenario. By the time we check all these, we're covering the full range of possible inputs that might break or confuse our method.</p>
    </subsubsection>

    <subsubsection xml:id="replace-implementation">
      <title>8.3 <c>replace</c> Implementation &amp; Tests</title>
      <p>The <c>replace</c> logic is more elaborate, but we'll follow the same approach. We'll treat <c>null</c> <c>find</c> or <c>replacement</c> as invalid inputs that throw exceptions, and we'll forcibly truncate the result at 100 characters.</p>
      <program language="java">
        <input>
/**
 * Returns a new MyString with every occurrence of 'find' replaced 
 * by 'replacement', non-overlapping from left to right,
 * truncated to 100 chars if needed.
 *
 * @throws NullPointerException if find or replacement is null
 * @param find the substring to find
 * @param replacement the substring to replace with
 */
public MyString replace(String find, String replacement) {
    if (find == null || replacement == null) {
        throw new NullPointerException("replace parameters cannot be null");
    }
    // If find is empty, we must decide a policy. We'll do what Java does: 
    //     replace("", "X") => inserts "X" before each character + one extra at the end.
    // For simplicity, let's skip that or treat it as an error:
    if (find.length() == 0) {
        throw new IllegalArgumentException("Cannot replace an empty string in this simplified version");
    }

    // We'll build the result in a StringBuilder, then truncate
    StringBuilder sb = new StringBuilder();

    int i = 0;
    while (i &lt; usedLength) {
        // Check if the substring at i matches 'find'
        boolean match = true;
        if (i + find.length() &lt;= usedLength) {
            for (int j = 0; j &lt; find.length(); j++) {
                if (chars[i + j] != find.charAt(j)) {
                    match = false;
                    break;
                }
            }
        } else {
            match = false;
        }

        if (match) {
            // Append replacement
            sb.append(replacement);
            // Skip ahead by length of 'find'
            i += find.length();
        } else {
            // Copy current character
            sb.append(chars[i]);
            i++;
        }

        // Check length limit
        if (sb.length() >= 100) {
            // Truncate to 100 and break
            sb.setLength(100);
            break;
        }
    }

    // Convert to MyString, possibly truncated
    String finalStr = sb.toString();
    return new MyString(finalStr);
}

// Quick test snippet in main:
public static void main(String[] args) {
    // ...
    MyString m3 = new MyString("banana banana");
    MyString replaced = m3.replace("ana", "X");
    System.out.println("replace('ana','X') => " + replaced.toString()); 
    // Expect "bXna bXna"

    // If find is not present => unchanged
    MyString untouched = m3.replace("zzz","!");
    System.out.println("replace('zzz','!') => " + untouched.toString()); 
    // Expect "banana banana"

    // Overlapping "ana" is replaced non-overlapping => tested above
    // Large expansions => we rely on truncated output if > 100 chars
    // ...
}
        </input>
      </program>
      <p>Each row in our <c>replace</c> test table now translates to a handful of lines in our test snippet. If we decide to handle <c>""</c> (empty <c>find</c>) differently, we can do so—but the table ensures we either do it or fail a test. In other words, Step 3's explicit listing of cases is what keeps us honest!</p>
    </subsubsection>
  </subsection>

  <!-- =====================================================
       9. FINAL COMPLETE DEMO CLASS
       ===================================================== -->
  <subsection xml:id="final-demo-class-step3">
    <title>Putting It All Together: <c>MyString</c> with substring/indexOf/replace</title>
    <p>The listing below consolidates everything—complete with a basic <c>toString()</c> method so printing is more natural. Note how each method's behavior lines up with the test tables from Step 3. That alignment is precisely the reason we say Step 3 is the “glue” that ties the rest of the Design Recipe together.</p>

    <program language="java" xml:id="MyStringFullStep3" interactive="activecode">
public class MyString {

    private char[] chars = new char[100];
    private int usedLength;

    public MyString(String source) {
        if (source.length() &gt; 100) {
            usedLength = 100;
        } else {
            usedLength = source.length();
        }
        for (int i = 0; i &lt; usedLength; i++) {
            chars[i] = source.charAt(i);
        }
    }

    public int length() {
        return usedLength;
    }

    public boolean isEmpty() {
        return (usedLength == 0);
    }

    public char charAt(int index) {
        if (index &lt; 0 || index &gt;= usedLength) {
            return '?';
        }
        return chars[index];
    }

    // For easier debugging/printing
    @Override
    public String toString() {
        // build a String from chars[0..usedLength-1]
        return new String(chars, 0, usedLength);
    }

    // ---------- New Methods Spotlighting Step 3 ---------- //

    /**
     * Returns a new MyString from [start, end).
     * Throws IndexOutOfBoundsException if invalid.
     */
    public MyString substring(int start, int end) {
        if (start &lt; 0 || end &lt; 0 || start &gt; end || end &gt; usedLength) {
            throw new IndexOutOfBoundsException(
                "Invalid substring range: [" + start + ", " + end + ") for length " + usedLength
            );
        }
        StringBuilder sb = new StringBuilder(end - start);
        for (int i = start; i &lt; end; i++) {
            sb.append(chars[i]);
        }
        return new MyString(sb.toString());
    }

    /**
     * Returns the first index where 'target' occurs, or -1 if none.
     * @throws NullPointerException if target is null
     */
    public int indexOf(String target) {
        if (target == null) {
            throw new NullPointerException("indexOf received null 'target'");
        }
        if (target.length() == 0) {
            return 0;
        }
        for (int start = 0; start &lt;= usedLength - target.length(); start++) {
            int i = 0;
            while (i &lt; target.length() &amp;&amp; chars[start + i] == target.charAt(i)) {
                i++;
            }
            if (i == target.length()) {
                return start;
            }
        }
        return -1;
    }

    /**
     * Returns a new MyString with every occurrence of 'find' replaced by 'replacement',
     * non-overlapping from left to right, truncated at 100 chars.
     */
    public MyString replace(String find, String replacement) {
        if (find == null || replacement == null) {
            throw new NullPointerException("replace parameters cannot be null");
        }
        if (find.length() == 0) {
            throw new IllegalArgumentException("Cannot replace empty find string in this simplified approach");
        }

        StringBuilder sb = new StringBuilder();
        int i = 0;
        while (i &lt; usedLength) {
            boolean match = false;
            if (i + find.length() &lt;= usedLength) {
                match = true;
                for (int j = 0; j &lt; find.length(); j++) {
                    if (chars[i + j] != find.charAt(j)) {
                        match = false;
                        break;
                    }
                }
            }
            if (match) {
                sb.append(replacement);
                i += find.length();
            } else {
                sb.append(chars[i]);
                i++;
            }
            if (sb.length() &gt;= 100) {
                sb.setLength(100);
                break;
            }
        }
        return new MyString(sb.toString());
    }

    // ---------- Quick Demo/Tests ---------- //
    public static void main(String[] args) {
        // substring quick checks
        MyString h = new MyString("Hello");
        System.out.println("h.substring(1,4) => " + h.substring(1,4)); // "ell"

        try {
            h.substring(-1, 2);
        } catch (IndexOutOfBoundsException e) {
            System.out.println("Caught expected IndexOutOfBounds for substring(-1,2)");
        }

        // indexOf checks
        MyString b = new MyString("banana");
        System.out.println("b.indexOf(\"ana\") => " + b.indexOf("ana")); // 1
        System.out.println("b.indexOf(\"ban\") => " + b.indexOf("ban")); // 0
        System.out.println("b.indexOf(\"cat\") => " + b.indexOf("cat")); // -1

        // replace checks
        MyString multi = new MyString("banana banana");
        MyString replaced = multi.replace("ana","X");
        System.out.println("replace('ana','X') => " + replaced); // "bXna bXna"
    }
}
    </program>
  </subsection>

  <!-- =====================================================
       10. SUMMARY & NEXT STEPS
       ===================================================== -->
  <subsection xml:id="summary-next-steps-spotlight3">
    <title>Summary &amp; Next Steps</title>
    <p>In this chapter, we spotlighted **Step 3: Examples &amp; Tests** in depth. You saw:</p>
    <ul>
      <li>**How** to build thorough test tables for three new string methods (<c>substring</c>, <c>indexOf</c>, <c>replace</c>), covering normal cases, edge conditions, and error scenarios.</li>
      <li>**Why** Step 3 is so critical—without enumerating these scenarios, we'd risk inconsistent or incomplete implementations.</li>
      <li>**Multiple ways** to transform these tables into real tests, from simple <c>assert</c> statements to more formal <c>JUnit</c> classes.</li>
      <li>**Final integrated code** that references each row of the test tables, preventing logical gaps or guesswork.</li>
    </ul>
    <p>This completes our demonstration of Step 3 in action. In the next sections, we'll continue to apply the Design Recipe systematically, potentially spotlighting Step 4 or Step 5 on more sophisticated string tasks or other data structures. For now, practice generating test tables for your own code—like <c>trim()</c>, <c>toUpperCase()</c>, or custom utility methods. You'll be amazed how many “hidden details” Step 3 uncovers!</p>
    <p>Remember: <strong>Every row in your example table must be verified by a line of test code</strong>. That's the essence of Step 3's reliability. Embrace it, and you'll write more robust, understandable, and maintainable software—no matter how simple or complex the methods become.</p>
  </subsection>
</section>