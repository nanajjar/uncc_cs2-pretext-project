<section xml:id="ch-practical-string-api">
  <title>More String Methods &amp; StringBuilder</title>

  <!-- =====================================================
       1. INTRODUCTION & MOTIVATION
       ===================================================== -->
  <subsection xml:id="sec-practical-string-intro">
    <title>Introduction &amp; Motivation</title>
    <p>Before we dive in, let's briefly discuss <term>exceptions</term>. In Java, when something goes wrong during program execution (like trying to use a value that doesn't exist), the program can throw an <term>exception</term> - a special signal indicating that an error occurred. For now, just know that exceptions can crash your program if not handled properly. We'll learn much more about exceptions and how to handle them in later chapters.</p>
    <p>In earlier chapters, we examined Java <c>String</c> fundamentals in depth—covering aspects like immutability, indexing, searching, comparing, and creating custom methods such as <c>substring</c>. While these core concepts are pivotal, you will frequently rely on Java's built-in <c>String</c> API for everyday tasks including <term>cleaning</term>, <term>splitting</term>, <term>transforming</term>, or <term>building</term> strings.</p>
    <p>This chapter offers a <term>toolbox</term> of essential, frequently used methods, supported by runnable code examples, cautionary notes, and real-world usage scenarios. Rather than methodically applying the entire Design Recipe, we'll emphasize <em>hands-on demonstrations</em> you can adopt immediately to write clearer, more efficient programs.</p>
    <p>By the end of this chapter, you will be able to:</p>
    <objectives>
      <ul>
        <li><term>Recognize</term> the right contexts to use built-in <c>String</c> methods such as <c>trim</c>, <c>replace</c>, and <c>split</c>.</li>
        <li><term>Avoid</term> typical mistakes involving locale configurations, regex symbols, and the cost of immutability.</li>
        <li><term>Use</term> <c>StringBuilder</c> effectively for concatenation in loops or large-scale text generation.</li>
        <li><term>Leverage</term> <c>String.format</c> and <c>printf</c> for more flexible templated output.</li>
      </ul>
    </objectives>
  </subsection>

  <!-- =====================================================
       2. TRIMMING & CLEANING INPUT
       ===================================================== -->
  <subsection xml:id="sec-trimming-cleaning">
    <title>Trimming &amp; Cleaning Input</title>
    <p>In real applications, strings often come from external sources (user input, files, network data) and may include leading/trailing whitespace or unexpected spacing. Java provides <c>trim()</c> (and in newer versions, <c>strip()</c>) to remove whitespace from both ends of a string, ensuring cleaner inputs.</p>
    <program language="java">
      <input>
public class TrimDemo {
    public static void main(String[] args) {
        String raw = "   Hello, world!   ";
        System.out.println("Original length: " + raw.length());

        String trimmed = raw.trim();
        System.out.println("Trimmed length: " + trimmed.length());
        System.out.println("Trimmed text: [" + trimmed + "]");

        // For Java 11+, strip() uses Unicode-aware rules:
        // (But if you only have an older version, trim() suffices for typical usage)
        String stripped = raw.strip();
        System.out.println("Stripped length: " + stripped.length());
        System.out.println("Stripped text: [" + stripped + "]");
    }
}
      </input>
    </program>
    <p>Running this code shows how <c>trim()</c> or <c>strip()</c> removes leading and trailing whitespace, producing a more uniform format from user-typed input.</p>
    <p><term>Common Pitfalls:</term></p>
    <ul>
      <li><em><b>Null Values</b>:</em> If you try to call <c>trim()</c> on a string that doesn't exist (has value <c>null</c>), your program will crash with an exception. Always make sure your string exists before using it!</li>
      <li><em><b>Unicode Whitespace</b>:</em> <c>trim()</c> only removes characters &lt;= '\u0020', whereas <c>strip()</c> (Java 11+) handles more Unicode whitespace. In most English-oriented code, <c>trim()</c> is fine, but be mindful of differences if you need internationalization.</li>
    </ul>
  </subsection>

  <!-- =====================================================
       3. CHANGING CASE: toLowerCase() & toUpperCase()
       ===================================================== -->
  <subsection xml:id="sec-case-conversion">
    <title>Changing Case: <c>toLowerCase()</c> &amp; <c>toUpperCase()</c></title>
    <p>Converting text to a uniform case is a quick way to handle case-insensitive comparisons or store data in a normalized form. For example:</p>
    <program language="java">
      <input>
public class CaseConversion {
    public static void main(String[] args) {
        String username = "Alice";
        
        // Store everything as lowercase internally
        String lowercase = username.toLowerCase();
        System.out.println("lowercase => " + lowercase); // "alice"

        // Or uppercase for emphasis
        String uppercase = username.toUpperCase();
        System.out.println("uppercase => " + uppercase); // "ALICE"

        // Example usage: checking user commands ignoring case
        String command = "HeLp";
        if (command.toLowerCase().equals("help")) {
            System.out.println("User requested help!");
        }
    }
}
      </input>
    </program>
    <p><term>Common Pitfalls:</term></p>
    <ul>
      <li><em><b>Locale Sensitivity</b>:</em> Languages like Turkish have uppercase/lowercase mappings that differ from English. Java provides <c>toLowerCase(Locale)</c> and <c>toUpperCase(Locale)</c> for custom behavior. By default, your platform's locale is used, which is typically acceptable, but keep i18n in mind.</li>
      <li><em><b>Null Strings</b>:</em> As with <c>trim()</c>, trying to use these methods on a non-existent string will cause your program to crash.</li>
    </ul>
  </subsection>

  <!-- =====================================================
       4. REPLACING TEXT: replace() & replaceAll()
       ===================================================== -->
  <subsection xml:id="sec-replacing-text">
    <title>Replacing Text: <c>replace()</c> &amp; <c>replaceAll()</c></title>
    <p>Often you'll need to alter or remove substrings—e.g., sanitizing user inputs, removing punctuation, or transforming placeholders. Java provides:</p>
    <ul>
      <li><p><c>replace(oldChar, newChar)</c> or <c>replace(CharSequence, CharSequence)</c> <term>performs a literal replacement</term> without regex interpretation.</p></li>
      <li><p><c>replaceAll(String regex, String replacement)</c> <term>uses regex</term>, treating the first argument as a regular expression.</p></li>
    </ul>
    <program language="java">
      <input>
public class ReplaceDemo {
    public static void main(String[] args) {
        String original = "Cats are great, cats are interesting.";
        
        // 1) Literal replacement of substring
        String replaced = original.replace("cats", "dogs");
        System.out.println("After replace(): " + replaced);
        // Notice "Cats" didn't change because "cats" != "Cats" (case differs)
        
        // 2) Regex-based replacement
        // Let's remove punctuation by replacing any non-word (\W) characters
        // with a space, except we might keep spaces.
        // This example is simplified for demonstration:
        String noPunct = original.replaceAll("[^a-zA-Z0-9 ]", "");
        System.out.println("After replaceAll(): " + noPunct);
    }
}
      </input>
    </program>
    <p><term>Common Pitfalls:</term></p>
    <ul>
      <li><em><b>Regex gotchas</b>:</em> <c>"."</c> is a regex wildcard, so <c>replaceAll(".", "_")</c> matches every character. For literal dots, use <c>"\\."</c>.</li>
      <li><em><b>Case Sensitivity</b>:</em> Replacements are case-sensitive unless you employ a case-insensitive regex flag (<c>"(?i)"</c>) or manually convert the string's case.</li>
      <li><em><b>Performance</b>:</em> <c>replaceAll</c> compiles a regex pattern. If you just need a straightforward literal change, <c>replace</c> is faster and simpler.</li>
    </ul>
  </subsection>

  <!-- =====================================================
       5. SPLITTING & JOINING
       ===================================================== -->
  <subsection xml:id="sec-splitting-joining">
    <title>Splitting &amp; Joining</title>
    <p>Splitting a string into tokens is common—e.g., reading CSV input or splitting a command into words. The method <c>split(String regex)</c> divides a string based on regex matches, while <c>String.join</c> reassembles arrays or lists with a given delimiter.</p>
    <program language="java">
      <input>
public class SplitJoinDemo {
    public static void main(String[] args) {
        // 1) Splitting a CSV-like line
        String line = "alice,bob,charlie";
        String[] parts = line.split(",");
        System.out.println("Number of parts: " + parts.length);
        for (String p : parts) {
            System.out.println(" - " + p);
        }

        // 2) Splitting on a period requires escaping the regex wildcard:
        String sentence = "Hello.World";
        // If we just do split("."):
        //   line.split(".") => that means "split on ANY character"
        // so let's do:
        String[] safer = sentence.split("\\.");
        System.out.println("Split on literal period:");
        for (String s : safer) {
            System.out.println(s);
        }

        // 3) Rejoining a list of tokens
        String joined = String.join(";", parts);
        System.out.println("Rejoined with semicolons => " + joined);
    }
}
      </input>
    </program>
    <p><term>Common Pitfalls:</term></p>
    <ul>
      <li><em><b>Regex vs. Literal Splits</b>:</em> The <c>split()</c> method always interprets your delimiter as a regex. Special characters like <c>"."</c>, <c>"|"</c>, or <c>"^"</c> must be escaped (<c>"\\."</c>).</li>
      <li><em><b>Empty Splits</b>:</em> By default, <c>split()</c> discards trailing empty strings. If you need them, specify a limit or carefully examine the result.</li>
      <li><em><b>Null Items</b>:</em> If you try to split a non-existent string, your program will crash. Always ensure your string exists before splitting it!</li>
    </ul>
  </subsection>

  <!-- =====================================================
       6. STRINGBUILDER FOR EFFICIENT CONCATENATION
       ===================================================== -->
  <subsection xml:id="sec-stringbuilder">
    <title>StringBuilder for Efficient Concatenation</title>
    <p>Because Java <c>String</c>s are <term>immutable</term>, each concatenation can create a new object. This overhead is fine for small, infrequent operations, but can become costly in loops or extensive string assembly.</p>
    <p><c>StringBuilder</c> (or <c>StringBuffer</c>) mitigates this by maintaining a mutable character sequence that supports fast <c>append</c>, <c>insert</c>, and <c>delete</c> operations.</p>
    <program language="java">
      <input>
public class StringBuilderDemo {
    public static void main(String[] args) {
        // Suppose we want to build a large message from many parts:
        StringBuilder sb = new StringBuilder();

        sb.append("Hello");
        sb.append(", ").append("world!");
        // Repeated appends are fast because we don't copy the whole string each time

        sb.append(" Current time is: ");
        sb.append(System.currentTimeMillis());

        // When finished, convert to an immutable String
        String result = sb.toString();
        System.out.println(result);

        // We can also do advanced edits:
        // Insert or delete:
        sb.insert(5, "(INSERTED)");
        System.out.println("After insert => " + sb);

        sb.delete(5, 14);
        System.out.println("After delete => " + sb);

        // Or replace:
        sb.replace(0, 5, "Hi");
        System.out.println("After replace => " + sb);
    }
}
      </input>
    </program>
    <p><term>Common Pitfalls:</term></p>
    <ul>
      <li><em><b>Forgetting to Call <c>toString()</c></b>:</em> Passing a <c>StringBuilder</c> to a method expecting a <c>String</c> can be a mistake. Finalize your text with <c>builder.toString()</c>.</li>
      <li><em><b>One-Off Cases</b>:</em> For small concatenations (two or three strings), <c>StringBuilder</c> offers limited benefit. Java often optimizes simple string concatenation internally.</li>
      <li><em><b>StringBuffer vs. StringBuilder</b>:</em> <c>StringBuffer</c> is thread-safe. In single-threaded code, <c>StringBuilder</c> is typically faster and preferred.</li>
    </ul>
  </subsection>

  <!-- =====================================================
       7. STRING FORMAT & PRINTF
       ===================================================== -->
  <subsection xml:id="sec-string-format">
    <title>Formatting Strings: <c>String.format</c> &amp; <c>printf</c></title>
    <p><c>String.format</c> allows you to build complex strings using a printf-style template, which can be much more readable than multiple concatenations—particularly when mixing different data types in the same output.</p>
    <program language="java">
      <input>
public class FormatDemo {
    public static void main(String[] args) {
        // 1) Basic usage: format strings with placeholders
        int qty = 3;
        double price = 9.99;
        String item = "Notebook";

        String line = String.format("Purchased %d %ss at $%.2f each", 
                                    qty, item, price);
        System.out.println(line);
        // => "Purchased 3 Notebooks at $9.99 each"

        // 2) Using System.out.printf (similar to format, but prints directly)
        System.out.printf("Hello %s, you have %d new messages.%n", "Alice", 5);
        // => "Hello Alice, you have 5 new messages."
    }
}
      </input>
    </program>
    <p><term>Common Pitfalls:</term></p>
    <ul>
      <li><em><b>Print vs. Return</b>:</em> <c>String.format</c> returns a new string, whereas <c>printf</c> writes directly to the output stream.</li>
      <li><em><b>Mismatch in Placeholders</b>:</em> Ensure <c>%d</c> is used for integers, <c>%f</c> for floating-point values, <c>%s</c> for strings, etc. Using the wrong specifier can cause errors or unexpected results.</li>
      <li><em><b>Locale Considerations</b>:</em> By default, <c>String.format</c> applies your system's locale. If you need special numeric or date formats, provide a <c>Locale</c> argument to <c>String.format</c>.</li>
    </ul>
  </subsection>

  <!-- =====================================================
       8. CONCLUSION & NEXT STEPS
       ===================================================== -->
  <subsection xml:id="sec-practical-string-conclusion">
    <title>Conclusion &amp; Next Steps</title>
    <p>Java's <c>String</c> class delivers a <term>rich suite</term> of methods for trimming, replacing, splitting, and joining text, plus a dedicated <c>StringBuilder</c> for efficient in-memory construction. These built-ins save significant effort over coding everything manually (as we did in earlier <c>MyString</c> examples).</p>
    <p>Here's how to apply them routinely:</p>
    <ul>
      <li><p><term>Cleaning &amp; Validation:</term> Use <c>trim()</c> or <c>strip()</c> on user inputs before storage or comparisons. Convert to a consistent case (e.g., <c>toLowerCase()</c>) if logic ignores case.</p></li>
      <li><p><term>Transforming &amp; Tokenizing:</term> Use <c>replace()</c> for literal changes or <c>replaceAll()</c> for pattern-based transformations (mind regex intricacies!). Break strings into arrays with <c>split(...)</c>, then recombine them via <c>String.join(...)</c>.</p></li>
      <li><p><term>Performance &amp; Assembly:</term> For building large or repetitive text, use <c>StringBuilder</c> for speed, then finalize with <c>.toString()</c>.</p></li>
      <li><p><term>Formatting &amp; Output:</term> <c>String.format</c> or <c>printf</c> simplifies complex output—especially if mixing multiple placeholders or controlling numeric precision.</p></li>
    </ul>
    <p>If you'd like some <term>practice</term> right now, try these short exercises:</p>
    <ul>
      <li><p>Write a method <c>cleanInput</c> that accepts a <c>String</c>, trims it, removes punctuation using <c>replaceAll("[^a-zA-Z0-9 ]", "")</c>, and returns the result.</p></li>
      <li><p>Split a text file's lines on commas, convert each piece to uppercase, and then join them with semicolons.</p></li>
      <li><p>Construct a multi-line report with 10 lines of dynamic data. Compare doing it with repeated <c>+</c> versus using <c>StringBuilder</c>. If possible, measure any performance difference!</p></li>
    </ul>
    <p>Now you have a more <term>practical toolkit</term> for handling strings. While the <term>Design Recipe</term> remains invaluable for learning low-level string manipulation, the built-in methods will streamline your code for real-world scenarios.</p>
  </subsection>
</section>