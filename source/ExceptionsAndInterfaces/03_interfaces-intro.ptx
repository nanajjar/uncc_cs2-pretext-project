<section xml:id="ch-interfaces-intro">
  <title>Introducing Interfaces</title>

  <!-- =========================================
       1. Narrative Setup & Motivation
       ========================================= -->
  <subsection xml:id="interfaces-motivation">
    <title>A Media Player with Multiple Classes</title>
    <p>Suppose you want to write a simple media player that can handle multiple types of content—like music tracks, podcasts, or audiobooks. Initially, you might write two separate classes:</p>
    <program language="java">
      <input>
// Two different classes with different method names
public class MusicTrack {
    public void playMusic() {
        System.out.println("Playing music…");
    }
}

public class PodcastEpisode {
    public void startPlaying() {
        System.out.println("Playing podcast…");
    }
}
      </input>
    </program>
    <p>Then you attempt to create a single method <c>playMedia</c> that handles either kind of content. A naive approach might look like this:</p>
    <program language="java">
      <input>
public static void playMedia(Object media) {
    if (media instanceof MusicTrack) {
        ((MusicTrack) media).playMusic();
    } else if (media instanceof PodcastEpisode) {
        ((PodcastEpisode) media).startPlaying();
    }
}
      </input>
    </program>
    <p>Here, two <strong>new</strong> concepts appear:</p>
    <ul>
      <li><term><c>instanceof</c></term>: Checks if an object belongs to a specific class.</li>
      <li><term>Casting</term>: Explicitly tells Java the type of the object. It's like labeling a generic "box" (<c>Object</c>) with a specific sticker (this is actually a <c>MusicTrack</c>!).</li>
    </ul>
    <p><strong>Why use <c>Object</c> at all?</strong> Because <c>Object</c> is Java's most general type—every class in Java automatically extends <c>Object</c>. This approach "works," but is <strong>awkward</strong> and <strong>error-prone</strong>:</p>
    <ul>
      <li>You must cast separately for each type—imagine adding more classes like <c>Audiobook</c>, <c>Livestream</c>, etc.</li>
      <li>Different method names (<c>playMusic()</c> vs. <c>startPlaying()</c>) force multiple conditional checks.</li>
    </ul>
    <p><strong>Wouldn't it be simpler</strong> if each class used the <em>same method name</em>, such as <c>play()</c>? Then you could eliminate <c>instanceof</c> and casting entirely. That's exactly what Java <term>interfaces</term> help us achieve—defining a "contract" (e.g., <c>void play()</c>) that every implementor must fulfill. Java's compiler <em>enforces</em> this contract by refusing to compile code that breaks it.</p>

    <p><strong>Mini Example: Compiler Enforcement in Action</strong></p>
    <program language="java">
      <input>
// A tiny interface as a contract
public interface MiniInterface {
    void doSomething();
}

// A class that 'implements' MiniInterface
// but FAILS to provide doSomething():
public class BadImplementation implements MiniInterface {
    // forgot doSomething()!
}
      </input>
      <output>
BadImplementation.java:1: error: BadImplementation is not abstract
and does not override abstract method doSomething() in MiniInterface
public class BadImplementation implements MiniInterface {
       ^
1 error
      </output>
    </program>
    <p><strong><em>Encouragement About Errors</em>:</strong> Don't worry if you see errors like these! <em>Compiler errors are your friend</em>—they point you straight to what's missing or incorrect. Encountering them is normal and expected. <em>Every</em> programmer repeatedly relies on compiler feedback to correct mistakes quickly, rather than hunting for them at runtime.</p>
  </subsection>

  <!-- =========================================
       2. Interfaces: Syntax & Basic Usage
       ========================================= -->
  <subsection xml:id="interfaces-definition">
    <title>Interface Syntax: A Compiler-Enforced Contract</title>
    <p>An interface in Java is like a <strong>contract</strong> that says, "Any class that implements me promises to contain certain methods." Inside an interface, you only write <strong>method signatures</strong>—no actual code bodies. Java then ensures at compile time that implementing classes match those signatures exactly.</p>
    <p>Below is the <strong>basic syntax</strong> for declaring an interface, broken down step by step:</p>
    <program language="java">
      <input>
/*
 * 1) 'interface' keyword declares that this is an interface (not a class).
 * 2) InterfaceName should be capitalized, like a class.
 * 3) Each method signature is implicitly 'public abstract'.
 */
public interface InterfaceName {

    /*
     * A method signature, with:
     *  - return type (e.g., void, int, etc.)
     *  - method name (e.g., play, computeArea, etc.)
     *  - any parameters (e.g., none or (String message), etc.)
     */
    returnType methodName(parameterList);

    // You can define multiple signatures if needed
    returnType anotherMethod(...);
}
      </input>
    </program>
    <p><strong>Why <c>public abstract</c>?</strong></p>
    <ul>
      <li><em>public</em> ensures the method is accessible to any class that wants to implement the interface (hence you can't have a private or package-private method signature fulfilling a public interface requirement—this leads to a compiler error).</li>
      <li><em>abstract</em> means there's no method body—just a promise that classes will provide the details.</li>
    </ul>
    <p><em>Important</em>: If a class tries to implement an interface method but <em>omits</em> `public` (for instance, using package-private or private), Java will complain that it doesn't match the interface's public method signature.</p>
    <p>For our media example, let's create a simple <c>Playable</c> interface with one method, <c>play()</c>:</p>
    <program language="java">
      <input>
/**
 * Represents any media content that can be "played."
 *
 * Classes implementing Playable promise to provide
 * a 'play()' method, ensuring a consistent way to
 * start the media.
 */
public interface Playable {

    /**
     * Starts playing this media content from the beginning.
     */
    void play();  // no method body allowed here
}
      </input>
    </program>
    <p><em>Tip:</em> Start with a minimal interface (maybe just <c>void play()</c>) and later add more methods if needed. This matches the Design Recipe's "incremental" approach.</p>

    <p><strong>Detailed JavaDoc Example</strong></p>
    <p>Below is a more advanced snippet showing how JavaDoc might look with <c>@param</c>, <c>@return</c>, and <c>@throws</c> tags—and <em>why</em> they matter:</p>
    <program language="java">
      <input>
/**
 * AdvancedMedia is anything that can be played from
 * a specific start position.
 *
 * In IDEs like VS Code or IntelliJ, these comments
 * appear as tooltips when you hover over 'playFrom'.
 * Also, 'javadoc' commands can generate an HTML site
 * from these tags automatically.
 */
public interface AdvancedMedia {

    /**
     * Start playing from a specific position (in seconds).
     * 
     * @param startPosition the playback position in seconds,
     *                      must be non-negative
     * @throws IllegalArgumentException if startPosition is negative
     */
    void playFrom(int startPosition);
}
      </input>
    </program>
    <p><strong>@param</strong> explains each parameter, <strong>@throws</strong> indicates when an exception is thrown, and <strong>@return</strong> (not shown here) describes what a method returns. <em>These tags help others (and you!) quickly see how to call or implement the method</em>.</p>

    <p><strong>Compiler Error Mini Example</strong></p>
    <program language="java">
      <input>
// Suppose our interface is:
public interface ExampleInterface {
    void doSomething();
    void doAnotherThing();
}

// Class that implements only one method, forgetting doAnotherThing():
public class PartialImplementation implements ExampleInterface {

    @Override
    public void doSomething() {
        System.out.println("Did something!");
    }
    // 'doAnotherThing()' is missing!
}
      </input>
      <output>
PartialImplementation.java:1: error: PartialImplementation is not abstract
and does not override abstract method doAnotherThing() in ExampleInterface
public class PartialImplementation implements ExampleInterface {
       ^
1 error
      </output>
    </program>
    <p>Line by line, the compiler is saying: "<c>doAnotherThing()</c> was promised but not provided." This immediate feedback prevents silent runtime bugs. <em>If an interface has multiple methods, you must implement them all.</em></p>
  </subsection>

  <!-- =========================================
       3. Implementing an Interface in a Class
       ========================================= -->
  <subsection xml:id="interfaces-implements">
    <title>Using <c>implements</c> in a Class Declaration</title>
    <p>When a class says <c>implements SomeInterface</c>, it promises to provide <em>all</em> the methods defined by that interface. Let's update our <c>MusicTrack</c> and <c>PodcastEpisode</c> classes to implement <c>Playable</c>:</p>
    <program language="java">
      <input>
public class MusicTrack implements Playable {

    /**
     * The @Override annotation tells the compiler:
     * "I'm implementing a method from the interface."
     * If you misspell the method, you'll get a warning.
     */
    @Override
    public void play() {
        System.out.println("Playing music...");
    }
}

public class PodcastEpisode implements Playable {

    @Override
    public void play() {
        System.out.println("Playing podcast...");
    }
}
      </input>
    </program>
    <p><term>@Override</term> isn't strictly required, but it's <strong>highly recommended</strong>. It <em>explicitly</em> signals your intent to Java, and if you mismatch the signature (like <c>pLay()</c> or <c>play(String s)</c>), the compiler immediately warns you.</p>
    <p>With <c>implements</c>, the compiler ensures you match <c>void play()</c> exactly. If you omit <c>play()</c>, or if you rename it to something else, you'll get a compile-time error. For example:</p>
    <program language="java">
      <input>
// WRONG EXAMPLE: Missing 'play()'
public class Audiobook implements Playable {
    // no method provided!
}
      </input>
      <output>
Audiobook.java:1: error: Audiobook is not abstract and does not override
abstract method play() in Playable
public class Audiobook implements Playable {
       ^
1 error
      </output>
    </program>
    <p>This error means "you promised to implement <c>play()</c>, but you didn't!" The compiler halts, forcing you to fix the issue before running. Once we add the required method, it compiles fine:</p>
    <program language="java">
      <input>
// Correct fix:
public class Audiobook implements Playable {

    @Override
    public void play() {
        System.out.println("Playing audiobook...");
    }
}
      </input>
    </program>
    <p><strong>What if I want partial implementation?</strong> Then you can declare your class <c>abstract</c>, meaning it's not fully complete and can't be instantiated. <em><strong>Important Note for Beginners:</strong></em> Abstract classes are a more advanced feature you'll learn later. For now, if the compiler complains you haven't implemented all methods, simply add the missing ones to your class. <em>Later chapters will clearly teach abstract classes, so don't worry if this concept doesn't fully make sense yet.</em> Just focus on implementing all the interface methods in your regular classes for now.</p>
    <p><strong>Another mismatch example: Extra parameters or wrong return type</strong></p>
    <program language="java">
      <input>
public interface Playable {
    void play();
}

public class BadImplementation implements Playable {

    // This tries to use an extra parameter:
    @Override
    public void play(String track) { // but interface expects play()
        System.out.println("Attempting to play " + track);
    }
}
      </input>
      <output>
BadImplementation.java:1: error: BadImplementation is not abstract
and does not override abstract method play() in Playable
public class BadImplementation implements Playable {
       ^
1 error
      </output>
    </program>
    <p>The compiler clearly says "does not override abstract method <c>play()</c> in Playable," because <c>play(String)</c> is not the same signature as <c>play()</c>. Java's strictness ensures consistent method contracts.</p>
  </subsection>

  <!-- =========================================
       4. Methods That Use Interfaces
       ========================================= -->
  <subsection xml:id="interfaces-in-methods">
    <title>Writing a Method That Expects an Interface</title>
    <p>Now that <c>MusicTrack</c> and <c>PodcastEpisode</c> both implement <c>Playable</c>, let's simplify <c>playMedia</c> dramatically. Instead of accepting <c>Object media</c> and guessing its type, we can require a <c>Playable</c> parameter:</p>
    <program language="java">
      <input>
public static void playMedia(Playable media) {
    // Because 'media' implements Playable, it must have 'play()'.
    media.play(); 
}

public static void main(String[] args) {
    MusicTrack music = new MusicTrack();
    PodcastEpisode podcast = new PodcastEpisode();

    // Both are valid 'Playable' objects, so we can pass them in directly:
    playMedia(music);   // prints "Playing music..."
    playMedia(podcast); // prints "Playing podcast..."
}
      </input>
    </program>
    <p>No casting, no <c>instanceof</c>—just <c>media.play()</c>. If we later add:</p>
    <program language="java">
      <input>
public class Audiobook implements Playable {
    @Override
    public void play() {
        System.out.println("Playing audiobook...");
    }
}

// ... in main:
Audiobook book = new Audiobook();
playMedia(book); // prints "Playing audiobook..."
      </input>
    </program>
    <p>We don't need to modify the <c>playMedia</c> method at all. It automatically works with any new class that implements <c>Playable</c>. That's the power of interfaces for easily extending your code—<em>no need</em> to rewrite or expand older methods. If you created a new class <c>Livestream</c> implementing <c>Playable</c>, you could call <c>playMedia(new Livestream())</c> with zero changes elsewhere!</p>
    <p><strong>Real-World Analogy (Polymorphism):</strong> Think of a universal "Play" button that works on different devices: a DVD player, a streaming service, or a music player. Each device does something unique when you press "Play," but from your perspective, it's a single button. That's exactly what an interface method does in code: one method name (<c>play()</c>) triggers different implementations depending on the actual class or device.</p>
  </subsection>

  <!-- =========================================
       5. Polymorphism in Action: A Complete Runnable Example
       ========================================= -->
  <subsection xml:id="interfaces-polymorphism">
    <title>Polymorphism in Action: A Complete Runnable Example</title>
    <p>Let's tie everything together with a <em>fully runnable</em> project showing how polymorphism (i.e., "many forms") simplifies code when multiple classes share the same interface.</p>

    <p><strong><em>Incremental Building</em></strong> (Recommended Approach):  
    Beginners often get overwhelmed if they see multiple files at once. A better strategy is building up step by step:</p>
    <ol>
      <li><strong>Create the interface first:</strong> (e.g., <c>Playable.java</c>). Compile it alone (<c>javac Playable.java</c>) to check there are no typos.</li>
      <li><strong>Add one class at a time:</strong> For instance, write <c>MusicTrack.java</c> implementing <c>Playable</c>, then compile it. If you see a compiler error, fix it before moving on.</li>
      <li><strong>Write a small <c>main</c>:</strong> that just creates a <c>MusicTrack</c> object and calls some method. Compile and run to verify it works.</li>
      <li><strong>Add more classes incrementally:</strong> (e.g., <c>PodcastEpisode</c>, <c>Audiobook</c>) repeating the compile/test cycle each time. This prevents a flood of errors all at once.</li>
      <li><strong>Finally, unify them in a more comprehensive <c>MediaPlayer</c> class:</strong> with a full <c>main</c> method demonstrating all classes. If something breaks, you know which recent addition is likely responsible.</li>
    </ol>

    <p>Below is how the <em>final</em> set of files might look once you're done:</p>
    <p><strong>Project Folder:</strong></p>
    <pre>
MyInterfaceProject/
├── Playable.java
├── MusicTrack.java
├── PodcastEpisode.java
├── Audiobook.java
└── MediaPlayer.java
    </pre>
    <p>Then the code might look like this all together:</p>
    <program language="java">
      <input>
// Playable.java
public interface Playable {
    void play();
}

// MusicTrack.java
public class MusicTrack implements Playable {
    @Override
    public void play() {
        System.out.println("Playing music track...");
    }
}

// PodcastEpisode.java
public class PodcastEpisode implements Playable {
    @Override
    public void play() {
        System.out.println("Playing podcast episode...");
    }
}

// Audiobook.java
public class Audiobook implements Playable {
    @Override
    public void play() {
        System.out.println("Playing audiobook...");
    }
}

// MediaPlayer.java
public class MediaPlayer {

    public static void playMedia(Playable media) {
        media.play();
    }

    public static void main(String[] args) {
        Playable track = new MusicTrack();
        Playable podcast = new PodcastEpisode();
        Playable book = new Audiobook();

        playMedia(track);   // "Playing music track..."
        playMedia(podcast); // "Playing podcast episode..."
        playMedia(book);    // "Playing audiobook..."
    }
}
      </input>
    </program>
    <p><strong>How to compile &amp; run:</strong></p>
    <ul>
      <li><strong>Compile (step by step or all at once):</strong> In your project folder, run <c>javac *.java</c> to compile all <c>.java</c> files. If you prefer incremental compilation, do <c>javac Playable.java</c> first, then each new class as you create it.</li>
      <li><strong>Run:</strong> Then run <c>java MediaPlayer</c> to execute the <c>main</c> method in <c>MediaPlayer</c>.</li>
    </ul>
    <p>Notice you <em>don't</em> need to change <c>MediaPlayer</c> if you add a new class (like <c>Livestream</c>) implementing <c>Playable</c>. You can just do:</p>
    <program language="java">
      <input>
public class Livestream implements Playable {
    @Override
    public void play() {
        System.out.println("Streaming live...");
    }
}

// Then in main (or anywhere):
playMedia(new Livestream()); // prints "Streaming live..."
      </input>
    </program>
    <p>This is polymorphism. The same "playMedia" method call does different things depending on the object's class.</p>
  </subsection>

  <!-- =========================================
       6. Interfaces and the Design Recipe
       ========================================= -->
  <subsection xml:id="interfaces-design-recipe-connection">
    <title>Connecting Interfaces to the Design Recipe</title>
    <p>You've seen the <em>Design Recipe</em>—it has several steps that guide your coding process:</p>
    <p><strong>Step 0:</strong> Restate the problem. ("We need a consistent way to handle multiple media types with a single method.")<br/>
    <strong>Step 1:</strong> Data definitions. (Define <c>MusicTrack</c>, <c>PodcastEpisode</c>, <c>Audiobook</c> classes.)<br/>
    <strong>Step 2:</strong> Method signature &amp; purpose. (We specify "void play()" in <c>Playable</c>—a formal contract for media playing.)<br/>
    <strong>Step 3:</strong> Examples &amp; Tests. (Test each class to confirm <c>play()</c> prints or does what we expect—if we forget or mismatch, the compiler error helps us fast.)<br/>
    <strong>Step 4:</strong> Skeleton / Outline. (Briefly outline how <c>play()</c> will be implemented in each class.)<br/>
    <strong>Step 5:</strong> Implementation &amp; Reflection. (Fill in final code, verify tests, reflect on if more interface methods are needed.)</p>
    <p>Interfaces align perfectly with <em>Step 2</em>, turning your documented method signature into something the compiler enforces. If you skip or mismatch the method, the compiler halts and shows you exactly where to fix. This drastically reduces hidden bugs or guesswork about naming or parameters.</p>
  </subsection>

  <!-- =========================================
       7. Common Mistakes & Best Practices
       ========================================= -->
  <subsection xml:id="interfaces-best-practices">
    <title>Common Mistakes and Best Practices</title>
    <p>When you first learn interfaces, watch out for these pitfalls:</p>
    <ul>
      <li>
        <strong>Method signature mismatch</strong>:  
        If the interface says <c>void play()</c>, writing <c>void play(String trackName)</c> or <c>int play()</c> in the class breaks the contract. You'll see an error like:
        <pre>
BrokenImplementation.java:3: error: BrokenImplementation is not abstract
and does not override abstract method play() in Playable
        </pre>
        Because your method signature doesn't match <c>play()</c> exactly.
      </li>
      <li>
        <strong>Forgetting to implement all interface methods</strong>:  
        If an interface has multiple methods, every single one must be provided in your class. Missing just one triggers a compile error.
      </li>
      <li>
        <strong>Skipping @Override</strong>:  
        Not using <c>@Override</c> can hide signature mismatches. It's strongly recommended for clarity.
      </li>
      <li>
        <strong>Insufficient JavaDoc</strong>:  
        Document your interface with `<c>/** ... */</c>` so users and future implementors know exactly how to fulfill or call its methods. Mention `@param`, `@return`, `@throws` when relevant. 
        <br/><strong>(Remember:</strong> these tags can show up as tooltips in IDEs and can auto-generate HTML docs!)
      </li>
      <li>
        <strong>Big interface "bloat" (advanced caution)</strong>:  
        Dumping many unrelated methods into one interface can overcomplicate your design. Beginners might not face this immediately, but eventually you'll see the value in creating multiple, smaller interfaces that group cohesive methods together.
      </li>
      <li>
        <strong>Abstract classes vs. interfaces</strong>:  
        <em>This is an advanced topic you don't need to understand right now.</em> If you can't implement all methods, Java allows you to declare your class <c>abstract</c>, but this is a more advanced feature. We'll cover abstract classes in detail in a later chapter. For now, simply implement all the required interface methods in your class. If the compiler complains about missing methods, just add them - don't worry about making your class abstract yet.
      </li>
    </ul>
    <p>If you accidentally break these rules, the compiler generally points straight to the error, telling you which abstract method is missing or incorrectly matched. That's <em>the main advantage</em> of interface contracts: <em>you catch mistakes at compile time</em>, not at runtime.</p>
  </subsection>

  <!-- =========================================
       8. Reinforcing Your Understanding
       ========================================= -->
  <subsection xml:id="interfaces-reflection">
    <title>Reflection: Where Else Could Interfaces Help?</title>
    <p>Think back to any past projects or practice exercises. Did you have multiple classes that were supposed to share a similar capability (like <c>draw</c>, <c>calculateArea</c>, or <c>attack</c>) but used different method names or required messy conditionals?  
    <strong>Write down</strong> a short note describing a scenario from your own code. Then explain in a sentence or two how an interface (e.g., <c>Drawable</c>, <c>Shape</c>, or <c>Enemy</c>) could enforce a consistent method signature and simplify your design.  
    In the upcoming sections, you'll see how Java's <strong>built-in interfaces</strong> (<c>Comparable</c>, <c>Iterable</c>, etc.) do exactly the same thing, helping unify behaviors like sorting or enhanced for-loops across many classes.</p>
  </subsection>

  <!-- =========================================
       9. Exercises
       ========================================= -->
  <exercises>
    <exercise type="shortanswer">
      <title>Reasoning about Interfaces</title>
      <statement>
        <p>Explain in your own words: why does requiring each class to implement the same method signature (like <c>play()</c>) simplify your code compared to using <c>instanceof</c> and casting? Mention at least one advantage of catching interface-related errors at compile time, rather than at runtime.</p>
      </statement>
    </exercise>

    <exercise type="shortanswer">
      <title>Examining a Compiler Error</title>
      <statement>
        <p>Write an example of an interface-related compiler error (like forgetting a required method or using the wrong return type). Show the exact error message and explain how it helps you fix the issue quickly. Why is this better than discovering the problem only after running the code?  
        <strong>Hint:</strong> Try something like "public interface MultiMethod { void doX(); void doY(); }" and then implement only doX(). Compile, observe the error, and fix it.</p>
      </statement>
    </exercise>

    <exercise type="programming">
      <title>Create a <c>Drawable</c> Interface and Classes</title>
      <statement>
        <p>1) Define an interface <c>Drawable</c> with a single method <c>draw()</c>.</p>
        <p>2) Write two classes: <c>Circle</c> and <c>Rectangle</c>, each implementing <c>Drawable</c>.</p>
        <p>3) Create a method <c>drawShape(Drawable shape)</c> that calls <c>shape.draw()</c> on any <c>Drawable</c>.</p>
        <p>4) In a <c>main</c> method, test <c>drawShape</c> with both a <c>Circle</c> and a <c>Rectangle</c>.</p>
        <p><strong>Make a small mistake on purpose:</strong> for instance, omit <c>draw()</c> or rename it to <c>dra()</c>. Compile your code, look closely at the compiler's error. Then fix it and compile again, noting how quickly you can correct the issue thanks to the interface contract.</p>
      </statement>
    </exercise>

    <exercise type="shortanswer">
      <title>JavaDoc for an Interface</title>
      <statement>
        <p>Suppose you define an interface <c>Printable</c> with a single method <c>printData()</c>. Show how you would write <em>detailed</em> JavaDoc for it, using tags like <c>@param</c>, <c>@return</c>, or <c>@throws</c> if relevant. Explain in a sentence or two why JavaDoc is more powerful than a basic comment. Also note how these tags might appear in an IDE's hover-tooltips or an auto-generated docs site.</p>
      </statement>
    </exercise>
  </exercises>
</section>