<section xml:id="sec-arraylist-setup-tooling_scope">
  <title>Project Setup and Tooling Context</title>

  <introduction>
    <p>
      With the concepts of dynamic collections, interfaces, packages, and imports established, let's get your local development environment ready. This involves getting the starter project files and understanding the purpose of the different files and tools you'll encounter.
    </p>
  </introduction>

  <subsection xml:id="subsec-arraylist-getting-boilerplate-revised">
    <title>Getting and Opening the Boilerplate Project</title>
    <p>
      To ensure everyone starts with the correct structure, interfaces, and tests, we've prepared a <term>boilerplate</term> project (starter code). Follow these steps:
    </p>
    <ol>
      <li>
        <p>
          <term>Download:</term> Get the project ZIP file. <![CDATA[]]>
          <em>(TODO: Add link to download)</em>
        </p>
      </li>
      <li>
        <p>
          <term>Unzip/Extract:</term> Extract the contents of the ZIP file to a suitable location on your computer where you keep your course projects. This will create a main project folder (e.g., <c>arraylist-project</c> or similar).
        </p>
      </li>
      <li>
        <p>
          <term>Open in VSCode:</term> Launch Visual Studio Code. Go to <c>File</c> &gt; <c>Open Folder...</c> (or your OS equivalent) and select the main project folder you just extracted (e.g., <c>arraylist-project</c>). <term>Important:</term> Open the main folder itself, not just individual files or subfolders like <c>src</c>.
        </p>
      </li>
    </ol>
    <p>
      After opening the folder and letting VSCode initialize, take a look at the file explorer. You'll see the structure we've discussed, including <c>src/ADTs/ListADT.java</c>, <c>src/DataStructures/ArrayList.java</c> (which you'll implement), and some other files we haven't focused on yet.
    </p>
    <pre>
YourProjectFolder/
├── src/
│   ├── ADTs/
│   │   ├── CollectionADT.java
│   │   └── ListADT.java
│   └── DataStructures/
│       └── ArrayList.java  &lt;-- Your implementation file
├── test/
│   └── DataStructures/
│       └── ArrayListTest.java  &lt;-- Tests for your implementation
├── build.gradle.kts          &lt;-- ??? Build configuration
├── settings.gradle.kts       &lt;-- ??? Build configuration
└── ... (Other Gradle files)
    </pre>
  </subsection>

  <subsection xml:id="subsec-arraylist-making-sense-files">
    <title>Making Sense of the Project Files: Build and Test Tools</title>

    <p>
      You've got the source code files (<c>.java</c>) under <c>src/</c> organized into packages. But what about those other files, like <c>build.gradle.kts</c> and <c>ArrayListTest.java</c>? They relate to essential processes in software development: building the code and testing it.
    </p>

    <subsubsection xml:id="subsubsec-arraylist-build-tools">
      <title>The Build Process Problem and Build Tools (Gradle)</title>
      <p>
        <term>Problem:</term> As we discussed, compiling multiple <c>.java</c> files spread across different packages (<c>ADTs</c>, <c>DataStructures</c>) isn't as simple as just running <c>javac</c> on one file. The compiler needs to find all the related files (like <c>ListADT.java</c> when compiling <c>ArrayList.java</c>) and handle their dependencies correctly. Furthermore, our tests (<c>ArrayListTest.java</c>) rely on an external library, JUnit. How does our project get access to JUnit's code? Manually managing compilation paths (classpaths) and downloading library files for even moderately complex projects becomes extremely difficult and prone to errors.
      </p>
      <p>
        <term>Solution:</term> This complex process is automated using <term>build tools</term>. Our project uses <term>Gradle</term>, a popular Java build tool. Gradle reads instructions from configuration files – primarily <c>build.gradle.kts</c> – which tell it how to perform tasks like:
      </p>
      <ul>
        <li>Compiling all source code in the <c>src/</c> directory, respecting package structures.</li>
        <li>Automatically downloading and managing required external libraries (<term>dependencies</term>), such as JUnit, from online repositories.</li>
        <li>Compiling the test code in the <c>test/</c> directory.</li>
        <li>Running the unit tests using the specified framework (JUnit).</li>
        <li>(Often) Packaging the compiled code and resources into a distributable format (like a JAR file).</li>
      </ul>
      <p>
        <term>Scope:</term> For this chapter, you do <term>not</term> need to understand or modify the contents of <c>build.gradle.kts</c> or other Gradle files. It's important to know that Gradle is the tool working behind the scenes, making it possible to easily compile and test this multi-package project that depends on JUnit. We will simply use VSCode's interface (like the Test Explorer or potentially a 'Run' button) which triggers Gradle to do the necessary work automatically. Build tool configuration is <term>out of scope</term>.
      </p>
    </subsubsection>

    <subsubsection xml:id="subsubsec-arraylist-test-frameworks">
      <title>The Verification Problem and Testing Frameworks (JUnit)</title>
      <p>
        <term>Problem:</term> We need confidence that our <c>ArrayList&lt;T&gt;</c> implementation correctly fulfills the <c>ListADT&lt;T&gt;</c> contract. As we noted earlier, using simple <c>assert</c> statements in a <c>main</c> method becomes unmanageable for testing all the methods and edge cases thoroughly. We need an organized, repeatable, and automated way to verify our code's behavior.
      </p>
      <p>
        <term>Solution:</term> This is achieved using <term>unit testing</term> supported by <term>testing frameworks</term>. The file <c>test/DataStructures/ArrayListTest.java</c> contains unit tests specifically designed to check your <c>ArrayList</c> implementation. These tests are written using <term>JUnit</term>, the framework we mentioned before. JUnit provides features (like the <c>@Test</c> annotation you might see if you peek in the file, and methods like <c>assertEquals</c>, <c>assertTrue</c>, <c>assertThrows</c>) that make it easy to define individual test cases and automatically check if your code produces the expected results or throws the correct exceptions.
      </p>
      <p>
        <term>Scope:</term> The JUnit tests in <c>ArrayListTest.java</c> are provided for you. Your task, which is <term>in scope</term>, is to learn how to <term>run</term> these tests within VSCode (using its Test Explorer, which leverages Gradle and JUnit) and how to <term>interpret</term> the results – green check ✅ means pass, red X ❌ means fail. Failed tests will provide messages indicating what went wrong, guiding you to fix bugs in your <c>ArrayList.java</c> implementation. The process of <term>writing</term> unit tests using JUnit is <term>out of scope</term> for this chapter.
      </p>
    </subsubsection>

    <p>
      Understanding that these tools (Gradle, JUnit) and file structures (<c>src</c>, <c>test</c>, packages) exist to manage complexity and ensure correctness allows us to focus on our main task: implementing <c>ArrayList.java</c>.
    </p>
  </subsection>

   <p>
      With the project open in VSCode and the roles of the key files and background tools clarified, we are now fully prepared to apply the Design Recipe to the implementation of <c>ArrayList&lt;T&gt;</c>. Let's begin with Step 0: Understanding the Task.
   </p>

</section>