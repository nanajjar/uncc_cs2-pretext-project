<chapter xml:id="audrey-chaos">
  <title>Introduction: Music Library Example</title>

  <!-- ======================================
       1. Overview and Objectives
       ====================================== -->
  <section xml:id="overview-objectives">
    <title>Overview and Objectives</title>
    <p>
      This chapter follows Audrey, an avid music lover who wants to store her favorite songs in
      Python. Her initial goal is modest—track each song’s title and rating—but as soon as she adds
      new fields (like how often she’s listened to each song), her “quick fixes” begin to unravel.
      By chapter’s end, you will see how these cascading problems reflect a deeper design issue:
      without a clearly defined data layout, even small changes can break your code in surprising
      ways.
    </p>
    <p>After studying this chapter, you should be able to:</p>
    <p>
      <ul>
        <li>Identify the pitfalls of hard-coded list indices in a growing program.</li>
        <li>Use a straightforward approach (like searching by a unique identifier) instead of
          relying
          on row positions.</li>
        <li>Understand why adding just one more field can silently break existing code.</li>
        <li>Appreciate the importance of a well-defined data structure for robust, maintainable
          code.</li>
      </ul>
    </p>
    <p>
      <em>Note for transfer students:</em> If you’re new to Python, don’t worry. You’ll see short
      reminders about list syntax and indexing along the way. Our focus is less on advanced Python
      features and more on how <em>any</em> program can go astray when data is poorly planned. </p>
  </section>

  <!-- ======================================
       2. Audrey’s Journey
       ====================================== -->
  <section xml:id="audrey-journey">
    <title>Audrey’s Journey</title>
    <introduction>
      <p> Audrey’s story begins with a simple plan—store her favorite songs, each with a rating from <c>
        1</c> to <c>5</c>. Over time, she wants to add new features, like tracking how many times
        she’s listened to a song. Her solutions evolve incrementally, but never quite address the
        root design flaw: which field is where? Follow her code to see how small, innocuous changes
        can lead to confusion or data corruption if the data structure is never explicitly defined. </p>
    </introduction>


    <!-- 2.1. Initial Goal -->
    <subsection xml:id="initial-goal">
      <title>1. Initial Goal</title>
      <p> Audrey’s to-do list is straightforward: <ol>
          <li>Store a handful of songs, each with a rating (1–5).</li>
          <li>Update that rating by the song’s name.</li>
        </ol> She’s comfortable with basic
        Python: lists, loops, and indexing. However, she has never really <em>designed</em> a data
        layout from scratch. Let’s see how she starts. </p>

    </subsection>

    <!-- 2.2. Hard-Coded Indices -->
    <subsection xml:id="hard-coded-indices">
      <title>2. Hard-Coded Indices</title>
      <p> Audrey decides each song should be a list <c>[title, rating]</c>. She envisions it like
        this: </p>
      <listing xml:id="first-attempt">
        <title>Audrey’s Hard-Coded Indices</title>
        <caption>
          A simple nested list, with ratings at position 1. Adding or reordering items will make
          index-based updates unreliable.
        </caption>
        <program language="python">
          music_library = [
          ["Imagine", 5], # index 0
          ["Thriller", 4], # index 1
          ["Hey Jude", 5] # index 2
          ]

          # Change “Thriller” rating from 4 to 3
          music_library[1][1] = 3
          print(music_library)
        </program>
      </listing>
      <p> When run, Python prints <c>[['Imagine', 5], ['Thriller', 3], ['Hey Jude', 5]]</c>. At
        first, Audrey is pleased—it “just works.” But if she inserts another song above “Thriller,”
        then <c>[1][1]</c> might not be “Thriller” anymore. And if she changes each song to <c>[title,
        rating, play_count]</c>, index <c>[1]</c> might no longer refer to the rating. </p>
      <p>
        <em>Reflection:</em> Have you ever written code with “magic numbers” such as <c>array[3]</c>
        or <c>list[2]</c> and hoped it stayed correct? It might, until you add or remove data. </p>
    </subsection>

    <!-- 2.3. Incremental “Fixes” -->
    <subsection xml:id="incremental-fixes">
      <title>3. Incremental “Fixes”</title>
      <p> To avoid scattering <c>music_library[x][1]</c> everywhere, Audrey extracts that logic into
        a helper function: </p>
      <listing xml:id="index-helper">
        <title>Helper by Row Index</title>
        <caption>
          The row index helper reduces repeated code but still assumes rating is at index 1. Any
          reordering of fields will silently break this code.
        </caption>
        <program language="python">
          def update_rating_by_index(library, row_index, new_rating):
          library[row_index][1] = new_rating

          music_library = [
          ["Imagine", 5],
          ["Thriller", 4],
          ["Hey Jude", 5]
          ]

          update_rating_by_index(music_library, 1, 2) # "Thriller" at row 1
          print(music_library)
        </program>
      </listing>
      <p> The console output is <c>[['Imagine', 5], ['Thriller', 2], ['Hey Jude', 5]]</c>. Audrey no
        longer directly writes <c>[1][1]</c> in her main code, but if the library’s order changes,
        the <c>row_index</c> approach still breaks. She then tries searching by title: </p>
      <listing xml:id="title-based-update">
        <title>Searching by Title Instead of Memorizing Indices</title>
        <caption>
          Title-based helper is more robust than index-based, but still relies on knowing that
          rating is at index 1. Order changes could silently corrupt data.
        </caption>
        <program language="python">
          def find_song_index(library, song_title):
          for i in range(len(library)):
          if library[i][0] == song_title: # Title is at index 0
          return i
          return None

          def update_rating(library, song_title, new_rating):
          idx = find_song_index(library, song_title)
          if idx is not None:
          # rating is at index 1
          library[idx][1] = new_rating

          music_library = [
          ["Imagine", 5],
          ["Thriller", 4],
          ["Hey Jude", 5]
          ]

          update_rating(music_library, "Thriller", 1)
          print(music_library)
        </program>
      </listing>
      <p> The code prints <c>[['Imagine', 5], ['Thriller', 1], ['Hey Jude', 5]]</c>. That’s more
        flexible (we no longer rely on “Thriller is row 1”), but if Audrey changes each song to <c>[title,
        play_count, rating]</c>, this function might overwrite the wrong field. </p>
    </subsection>

    <!-- 2.4. Adding Play Counts -->
    <subsection xml:id="adding-play-counts">
      <title>4. Adding Play Counts</title>
      <p> A week later, Audrey wants to track how often she listens to each song. She modifies each
        entry to <c>[title, rating, play_count]</c>: </p>
      <listing xml:id="adding-field">
        <title>Introducing a New Field</title>
        <caption>
          Adding play_count changes field positions. Without a clear data definition, existing code
          might corrupt ratings when trying to update play counts.
        </caption>
        <program language="python">
          music_library = [
          ["Imagine", 5, 120],
          ["Thriller", 4, 230],
          ["Hey Jude", 5, 150]
          ]
        </program>
      </listing>
      <p> If her old <c>update_rating</c> still assumes <c>[1]</c> is the rating, that might hold
        true here. But if she decides to reorder fields or adds a function that tries to “update
        play count” using <c>[1]</c>, she could corrupt the rating. None of these incremental fixes
        address how the data is truly arranged. </p>
      <p>
        <em>Reflection:</em> A single “extra field” can break existing code if no one ever agreed on
        which index is rating vs. play count. </p>
    </subsection>
  </section>

  <!-- ======================================
       3. Why a Clear Data Layout Matters
       ====================================== -->
  <section xml:id="why-clear-layout">
    <title>Why a Clear Data Layout Matters</title>
    <p> Audrey’s story shows “band-aid” solutions—searching by row index, then by title—only work
      until the data format changes. Without a single definition of which element is <c>rating</c>
      or <c>play_count</c>, every function makes its own assumption. </p>
    <p> A more robust path is to explicitly define what a <c>Song</c> is. For example: </p>
    <blockquote>
      <p>
        <em>A Song is a Python list of the form [title, rating, play_count],
          where rating is an integer in the range 1–5 and play_count is a nonnegative integer.</em>
      </p>
    </blockquote>
    <p> From there, every function knows the layout. If Audrey adds <c>artist</c> later, she updates
      the definition and any code that relies on specific sublist indices. No guesswork or hidden
      breakage. </p>
    <p>
      In many introductory courses, the instructors hand you the data structure, so you never
      realize how fragile a “make it up as you go” approach can be. Audrey’s incremental chaos shows
      how crucial data definitions are, especially as a program grows.
    </p>
  </section>

  <!-- ======================================
       4. Reflection and Next Steps
       ====================================== -->
  <section xml:id="reflection-and-next-steps">
    <title>Reflection and Next Steps</title>
    <p>
      Audrey introduced multiple “fixes”—searching by row index, then by title—yet never documented
      a unified structure for her songs. Each new field threatened to break her old code.
    </p>
    <p>
      <em>Looking Forward:</em> In the next chapter, we will formally define a <c>Song</c> as part
      of a broader “Design Recipe.” By stating how each field is stored, we prevent the guesswork
      that led to Audrey’s problems. Adding new information (like <c>artist</c> or <c>release_year</c>)
      becomes a predictable update, rather than a gamble with list indices. </p>
    <p>
      <em>Key Takeaway:</em> Storing data is more than just picking the first quick fix—there must
      be a consistent structure. Otherwise, you risk repeating Audrey’s incremental chaos every time
      you add or reorder fields. </p>
  </section>
</chapter>