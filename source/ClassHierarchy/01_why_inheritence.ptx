<section xml:id="ch-class-hierarchy">
  <title>Why Inheritance?</title>

  <p><term>Inheritance</term> is a fundamental mechanism in object-oriented programming where one class (the subclass) acquires the properties and behaviors of another class (the superclass). This establishes an "is-a" relationship, where the subclass represents a specialized version of the superclass. For example, a <c>SavingsAccount</c> is a specialized type of <c>BankAccount</c>.</p>
  
  <p>Consider this concrete example of inheritance in action:</p>
  
  <program language="java">
    <code>
// The superclass containing shared functionality
public class BankAccount {
    protected double balance;
    
    public void deposit(double amount) {
        if (amount &gt;= 0) {
            balance += amount;
        }
    }
    
    public void withdraw(double amount) {
        if (amount &gt;= 0 &amp;&amp; amount &lt;= balance) {
            balance -= amount;
        }
    }
}

// The subclass inherits and extends functionality
public class SavingsAccount extends BankAccount {
    private double interestRate;
    
    public void applyInterest() {
        balance += balance * interestRate;
    }
}
    </code>
  </program>
  
  <p>This example demonstrates how inheritance reduces code duplication: <c>SavingsAccount</c> automatically gains the <c>deposit</c> and <c>withdraw</c> methods without rewriting them. Yet it also extends this functionality with its own <c>applyInterest</c> method that's specific to savings accounts.</p>
  
  <p>While inheritance powerfully enables code reuse, it creates stronger coupling between classes than other reuse mechanisms. This means changes to the superclass can potentially affect all subclasses, sometimes in unexpected ways. Effective use of inheritance requires careful consideration of these relationships.</p>

  <p>Object-oriented programming offers several code reuse mechanisms, each serving different purposes:</p>
  <ul>
    <li><term>Methods:</term> Prefer simple methods when the shared functionality is a behavior that doesn't require shared state. <em>Example:</em> Use a utility method to calculate distance between two points, which can be called from any class.</li>
    <li><term>Interfaces:</term> Use when you need to define a contract that multiple unrelated classes should implement. <em>Example:</em> A <c>Movable</c> interface could be implemented by both <c>Player</c> and <c>Vehicle</c> classes, allowing them to share movement-related method contracts.</li>
    <li><term>Composition:</term> Choose when an object uses or contains another object but isn't a specialization of it. <em>Example:</em> A <c>Game</c> class containing <c>Player</c>, <c>Level</c>, and <c>Enemy</c> objects.</li>
    <li><term>Inheritance:</term> Apply only when there's a clear "is-a" relationship and tight coupling between parent and child is acceptable. <em>Example:</em> A <c>SavingsAccount</c> class extending a base <c>BankAccount</c> class.</li>
  </ul>
  
  <p>As a general guideline, favor composition as your default approach for code reuse. Composition creates more flexible, adaptable designs by reducing coupling between classes. Reserve inheritance for clear "is-a" relationships where shared behavior genuinely represents a specialization hierarchy.</p>

  <subsection xml:id="inheritance-dry-principle">
    <title>The DRY Principle: Avoiding Repeated Code</title>
    <p>In software development, repeating similar code across multiple classes can lead to significant issues. Consider a game that has multiple character types—such as <c>Player</c>, <c>Monster</c>, and <c>NPC</c>—each requiring common attributes like <c>health</c> and methods like <c>takeDamage()</c>. Without applying any reuse principles, your code might look like this:</p>
    <program language="java">
      <code>
public class Player {
    private int health;

    public void takeDamage(int amount) {
        health -= amount;
    }
}

public class Monster {
    private int health;

    public void takeDamage(int amount) {
        health -= amount;
    }
}

public class NPC {
    private int health;

    public void takeDamage(int amount) {
        health -= amount;
    }
}
      </code>
    </program>
    <p>Notice how the <c>takeDamage()</c> method and <c>health</c> field are identical in each class. Duplicating code this way is risky because:</p>
    <ul>
      <li>You must remember to update each class if the logic changes, which increases maintenance burden.</li>
      <li>It's easy to introduce inconsistencies or errors if you miss updating one class.</li>
      <li>The codebase quickly becomes bloated and difficult to manage.</li>
    </ul>
    <p>The <term>DRY principle (Don't Repeat Yourself)</term> advises avoiding this duplication by identifying and abstracting common behaviors into a single, shared implementation.</p>
    
    <p>Inheritance directly addresses the DRY principle by creating a shared parent class:</p>
    
    <program language="java">
      <code>
// Parent class with shared functionality
public class GameEntity {
    protected int health;
    
    public void takeDamage(int amount) {
        health -= amount;
    }
}

// Subclasses inherit common behavior and add specifics
public class Player extends GameEntity {
    private int experiencePoints;
    
    public void gainExperience(int amount) {
        experiencePoints += amount;
    }
}

public class Monster extends GameEntity {
    private boolean isAggressive;
    
    public void setAggressive(boolean aggressive) {
        isAggressive = aggressive;
    }
}
      </code>
    </program>
    
    <note>
      <p>While these examples show identical code duplication, inheritance is most appropriate when the duplicated elements represent a genuine specialization relationship. When shared behavior might evolve differently across classes or when the "is-a" relationship doesn't hold, consider alternatives like interfaces or composition.</p>
    </note>
    
    <p>For example, while a <c>Monster</c> genuinely is a <c>GameEntity</c>, a <c>Game</c> is not a <c>Player</c>—it contains or manages players. Consider this example of inappropriate inheritance:</p>
    <program language="java">
      <code>// Inappropriate inheritance example
public class Game extends Player {
    private List&lt;Monster&gt; monsters;
    
    // Game methods...
}
      </code>
    </program>
    
    <p>This design is problematic because a <c>Game</c> is not a specialized type of <c>Player</c>, yet it would inherit player-specific attributes like <c>health</c> and <c>experience</c> that don't make sense for a game. Additionally, changes to the <c>Player</c> class would unexpectedly affect the <c>Game</c> class. A better approach would use composition: <c>Game</c> would contain instances of <c>Player</c>, <c>Monster</c>, and other game elements.</p>
    
    <exercise type="reflection" xml:id="reflection-dry-principle">
      <title>Reflecting on Code Duplication</title>
      <statement>
        <p>Consider the following points in your reflection:</p>
        <ol>
          <li>Think about a time when you duplicated similar logic across multiple classes or methods. What specific issues did you encounter?</li>
          <li>How might following the DRY principle have helped in that situation?</li>
          <li>Sketch a simple inheritance hierarchy that could have solved the problem.</li>
        </ol>
      </statement>
      <solution>
        <p>Duplicating code led to bugs or wasted effort in maintenance, as each instance of duplicated code had to be updated independently. Following DRY would have consolidated logic, reduced mistakes, and simplified updates.</p>
        <p>A possible inheritance hierarchy might look like:</p>
        <program language="java">
          <code>
public class Parent {
    // Common fields and methods
    private int sharedField;
    
    public void sharedMethod() {
        // Shared implementation
    }
}

public class Child1 extends Parent {
    // Child-specific code
}

public class Child2 extends Parent {
    // Another child-specific code
}
          </code>
        </program>
      </solution>
    </exercise>
  </subsection>

  <subsection xml:id="composition-vs-inheritance">
    <title>Composition vs. Inheritance: Choosing Wisely</title>
    <p>There are two primary ways to reuse functionality between classes: <em>composition</em> and <em>inheritance</em>.</p>
    
    <p>In real-world design scenarios, the choice between these approaches often involves nuanced trade-offs rather than clear-cut decisions:</p>
    
    <p><term>Inheritance ("is-a" relationship):</term></p>
    <ul>
      <li><term>Advantages:</term>
        <ul>
          <li>Reuses code automatically without delegation</li>
          <li>Enables polymorphism through substitutability</li>
          <li>Creates clean, hierarchical organization</li>
        </ul>
      </li>
      <li><term>Disadvantages:</term>
        <ul>
          <li>Creates tight coupling that can make future changes difficult</li>
          <li>Can lead to fragile class hierarchies as depth increases</li>
          <li>Limited to single inheritance in Java (unlike multiple inheritance in some languages)</li>
          <li>Implementation details in the superclass may leak into subclasses</li>
        </ul>
      </li>
      <li><term>Example:</term> <c>Monster extends Entity</c> - A monster is a type of entity with specialized behaviors.</li>
    </ul>
    
    <p><term>Composition ("has-a" relationship):</term></p>
    <ul>
      <li><term>Advantages:</term>
        <ul>
          <li>Creates more flexible design with looser coupling</li>
          <li>Allows changing components at runtime</li>
          <li>Enables combining behaviors from multiple sources</li>
        </ul>
      </li>
      <li><term>Disadvantages:</term>
        <ul>
          <li>Requires more delegating code (forwarding methods)</li>
          <li>Class relationships can be less immediately obvious</li>
          <li>May need more code to implement the same functionality</li>
          <li>Can become complex if many components need coordination</li>
        </ul>
      </li>
      <li><term>Example:</term> <c>Player</c> has an <c>Inventory</c> object - A player contains but is not a type of inventory.</li>
    </ul>

    <p>A good starting question is: "Is this class genuinely a specialized version of another, or does it simply contain or use another object?" However, real designs often involve judgment calls where the lines blur. Many experienced developers adopt the "favor composition over inheritance" guideline while recognizing that inheritance is sometimes the clearer approach.</p>
    
    <p>It's also common to use both approaches together. For example, you might have a class hierarchy for game entities (inheritance) where each entity contains component objects like weapons or abilities (composition).</p>

    <exercise type="reflection" xml:id="reflection-composition-scenario">
      <title>When to Choose Composition</title>
      <statement>
        <p>For this exercise:</p>
        <ol>
          <li>Describe a scenario where composition is clearly a better choice than inheritance.</li>
          <li>Explain specifically why composition makes more sense in your example.</li>
          <li>Sketch what the classes might look like in Java using composition, showing at least two classes and their relationship.</li>
        </ol>
      </statement>
      <solution>
        <p>A document system provides a good example. A document isn't a specialized type of formatting style, but it contains formatting. Using inheritance would incorrectly imply a document is a type of formatting, while composition correctly models that a document has formatting.</p>
        <p>Using composition, the code might look like:</p>
        <program language="java">
          <code>
public class FormattingStyle {
    private String fontFamily;
    private int fontSize;
    
    public void applyTo(String text) {
        // Apply formatting logic
    }
}

public class Document {
    private String content;
    private FormattingStyle style; // Composition
    
    public Document(String content) {
        this.content = content;
        this.style = new FormattingStyle();
    }
    
    public void display() {
        style.applyTo(content);
        // Additional document display logic
    }
}
          </code>
        </program>
      </solution>
    </exercise>
  </subsection>

  <subsection xml:id="object-class-inheritance">
    <title>Object: The Ultimate Superclass</title>
    <p>Did you know you're already using inheritance in every Java class you write? In Java, all classes implicitly inherit from a superclass called <c>Object</c> if they don't explicitly extend another class. This means every class you create automatically receives methods like <c>toString()</c>, <c>equals()</c>, and <c>hashCode()</c>.</p>
    
    <p>This universal inheritance has profound implications for Java's design:</p>
    <ul>
      <li>It enables polymorphic handling of any object through the common <c>Object</c> reference type</li>
      <li>It establishes system-wide contracts for object comparison, string representation, and hashing</li>
      <li>It makes collections like <c>ArrayList</c> or <c>HashMap</c> possible, as they can store any object type</li>
    </ul>
    
    <p>Let's see what happens when we use inherited <c>Object</c> methods without overriding them:</p>
    
    <program language="java">
      <code>
public class Player {
    private String name;
    private int health;
    
    public Player(String name, int health) {
        this.name = name;
        this.health = health;
    }
    
    // No toString() override
}

// Later in code
Player hero = new Player("Hero", 100);
System.out.println(hero); // Outputs something like: Player@7a81197d
      </code>
    </program>
    
    <p>The output is not very readable because we're using the default <c>toString()</c> implementation inherited from <c>Object</c>. This default is deliberately minimal—Java can't assume what information would be meaningful for every possible class, so it provides a basic implementation that you're expected to override with class-specific behavior.</p>
    
    <p>This example illustrates an important inheritance concept: while inheriting methods is convenient, sometimes the parent class's implementation doesn't fit the specific needs of the subclass—a perfect scenario for method overriding, which we'll explore in the next chapter.</p>
  </subsection>
</section>